# 两数之和

## 题目描述

### 源地址

https://leetcode-cn.com/problems/two-sum/

### 描述

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

> 给定 `nums = [2, 7, 11, 15]`, `target = 9`。
>
> 因为 `nums[0] + nums[1] = 2 + 7 = 9`, 所以返回 `[0, 1]`。



## 解法

### 双层 `for` 循环

首先能想到的是暴力双层 `for` 循环，简单粗暴。

```typescript
function twoSum (nums: number[], target: number): number[] {
  const lens = nums.length;
  for (let i = 0; i < lens - 1; i++) {
    const leftNum = nums[i];
    const lastNum = target - leftNum;
    for (let j = i + 1; j < lens; j++) {
      const rightNum = nums[j];
      if (rightNum === lastNum) {
        return [i, j];
      }
    }
  }
  return [];
};
```

时间复杂度: O(n^2)

空间复杂度: O(1)

时间复杂度过高，我们想办法优化，使用空间换时间来解决

### 单层 `for` 循环 + `Map`

空间换时间，增加空间 `Map` 来提高查找效率，前面找过的值直接存入 `Map` ，后续找的时候直接在 `Map` 中查找。

```typescript
function twoSum3 (nums: number[], target: number): number[] {
  const numWeek = new Map();
  const lens = nums.length;
  let i = 0;
  while (i < lens) {
    const leftNum = nums[i];
    const lastNum = target - leftNum;
    if (numWeek.has(lastNum)) {
      return [numWeek.get(lastNum), i];
    }
    numWeek.set(leftNum, i);
    i++;
  }
  return [];
};
```

时间复杂度: O(n)

空间复杂度: O(n)

## 题目代码

[源码](../src/array/1.two-sum.ts)